{"meta":{"title":"Aniki","subtitle":null,"description":null,"author":"Aniki","url":"http://yoursite.com"},"pages":[{"title":"Tags","date":"2019-02-24T06:06:02.000Z","updated":"2019-02-24T07:35:04.346Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-02-24T06:02:24.000Z","updated":"2019-02-24T07:35:15.834Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"video caption","slug":"vedio-caption","date":"2019-02-24T08:07:40.000Z","updated":"2019-02-24T08:50:47.953Z","comments":true,"path":"2019/02/24/vedio-caption/","link":"","permalink":"http://yoursite.com/2019/02/24/vedio-caption/","excerpt":"Video captioning定义为一张图片产生一个描述被称为image caption任务,为一个视频产生一个描述成为video caption，但视频可以理解为在时间上有连续性的一组图片，因此可以理解成为一组图片产生一个描述。 video caption是属于对video analysis的高层语义分析。 描述一般描述两个方向，属性和相互关系。 三种基本方法： 1.基于模版的，较为简单，caption质量在很大程度上取决于句子的模板，句子用句法结构生成，多样性较差。 2.基于检索，一般来说，这个方法在固定场景内的视频中是有效的，因为嵌入空间可以很好地推广，并且更丰富的模型结构提高了性能。 然而，当遇到以前从未见过的情况的视频时，效果会很差。 此外，由于嵌入是固定长度的，因此它限制了视频和文本描述可以携带的信息量。","text":"Video captioning定义为一张图片产生一个描述被称为image caption任务,为一个视频产生一个描述成为video caption，但视频可以理解为在时间上有连续性的一组图片，因此可以理解成为一组图片产生一个描述。 video caption是属于对video analysis的高层语义分析。 描述一般描述两个方向，属性和相互关系。 三种基本方法： 1.基于模版的，较为简单，caption质量在很大程度上取决于句子的模板，句子用句法结构生成，多样性较差。 2.基于检索，一般来说，这个方法在固定场景内的视频中是有效的，因为嵌入空间可以很好地推广，并且更丰富的模型结构提高了性能。 然而，当遇到以前从未见过的情况的视频时，效果会很差。 此外，由于嵌入是固定长度的，因此它限制了视频和文本描述可以携带的信息量。 3.基于编码的方法， 更正式地说，这些工作提出的框架是一个编码器 - 解码器结构，它将视频编码为语义表示特征向量，然后解码为自然语言。 主要技术（attention,3D conv）双流法光流表达了图像的变化，由于它包含了目标运动的信息，因此可被观察者用来确定目标的运动情况，每张图像中每个像素的运动速度和运动方向找出来就是光流场。 采用双通道CNN的方式，对光流和图片同时处理得到结果，最后fusion一起。 一般的光流图为双通道的信息，分别为在X轴上的信息变化与Y轴上的信息变化。光流图是选择视频中的任意一帧的时间然后及其后面的N帧叠合成一个光流栈进入处理。 3D卷积由于视频帧之间具有时间连续性，普通的2D卷积不能够充分表达这个特性，因此把相邻的几个帧合在一起组成一个具有三个维度的输入向量，同时在这三个维度进行卷积。 3D卷积也只是一种增加时间信息的补充手段，实际使用中2D卷积的结果+3D卷积结果fusion一起的效果更好。 从LSTM-E和p-RNN的结果可以看出，视频处理中，3D卷积效果好于2D卷积，二者结合一起，效果更好。 3D CNN模型的主要特性有： 1）通过3D卷积操作核去提取数据的时间和空间特征，在CNN的卷积层使用3D卷积。 2）3D CNN模型可以同时处理多幅图片，达到附加信息的提取。 3）融合时空域的预测。 attention机制两种attention机制：软注意力机制（soft-attention）和硬注意力机制（hard-attention）。软注意力机制对每一个图像区域学习一个大小介于0与1之间的注意力权重，其和为1，再将各图像区域进行加权求和。硬注意力机制则将最大权重置为1，而将其他区域权重置0，以达到仅注意一个区域的目的。在实际的应用中软注意力机制得到了更广泛的应用。由于其良好的效果和可解释性，attention机制已经成为一种主流的模型构件。 attention机制计算方法 attention机制使用方法 如上所示，Attention基于先前时间的隐藏状态（其可能概括所有先前生成的帧）和对应帧的时间特征向量，为所有帧生成权重。 Attention机制由计算机视觉引入，在自然语言处理领域获得长足发展。而在image caption这样结合CV和NLP的领域，attention机制无疑是最有发展潜力的研究方向之一。 整体框架 整体分为三部分。第一部分抽取视频特征，有2D卷积帧抽取，3D卷积，以及2D卷积和3D卷积结合的方式第二部分对抽取出的视频特征进行处理，又称为encoder，有attention机制，直接pooling，LSTM以及多层级的encoder等，这部分的处理目的一般是为了考虑视频帧之间的时间连续性进行处理。第三部分就是就是常规的的decoder对编码信息进行解码翻译，有LSTM和GRU等。 一般情况下大都只是对第一部分和第二部分，重点在于如何充分考虑视频帧之间的的时间特性来抽取特征和对于抽取出来的特征如何进行更好的再编码。也有用强化学习做video captioning，另18CVPR提出四部分的video caption，多了一个reconstructor部分，达到了目前的state-of-the-art。 目前主要论文video caption的主要模型有如下几种 MP-LSTM[1] 该模型是第一个使用encoder-decoder模式来做video caption，框架如下： 对视频进行1/10的帧采样，采用AlexNet逐帧对图片进行卷积，对每帧图像的出来的结果之间进行mean pooling 得到固定的4096长度的向量，然后送入双层LSTM中处理得到caption。缺点是不能利用视频的时间关联性的特点。 S2VT[2] 该模型是第一个使用光流法做video caption的模型，框架如下： 主要特点为采用2D卷积+光流法组成encoder对视频进行了处理，从而获得了视频帧之间的时间信息，decoder为普通的双层LSTM。缺点为只能获取短时间内的光流信息。 SA[3] 该模型是第一个使用3D卷积和attention机制在video caption中的模型，该框架为后续改进的基本框架。 先用3D卷积获取局部的时间信息特征向量，解码器是带有attention机制的LSTM解码器对编码器生成的所有特征向量以不同权重进行加权采用GoogleNet的2D卷积提取帧1024特征向量 3层3D卷积网络处理视频信息，最后堆叠一起送入decoder decoder为带有attention的LSTM，soft attention机制可以有效帮助处理视频时间信息，通过生成$\\alpha$来确定输入输入视频帧的权重。通过强调不同帧的不同作用，有效帮助模型生成caption。 HRNE[4] encoder模型如下 该模型的特点为encoder不仅对视频帧进行特征抽取，而且用具有层级关系的RNN模型对特征进行处理，encoder利用了不同时间粒度上的信息，即在每一段的LSTM编码器上再加一个编码器来归纳和学习更长时间粒度上的特征信息。模型继续使用了上述的attention机制，取得了很好的效果。但是，它需要固定的手动设置子序列长度，因此它不适应不同类型的视频。 评价指标bleubleu是一种文本评估算法，它是用来评估机器翻译跟专业人工翻译之间的对应关系，核心思想就是机器翻译越接近专业人工翻译，质量就越好，经过bleu算法得出的分数可以作为机器翻译质量的其中一个指标。 优点：方便、快速，结果比较接近人类评分。 缺点： 不考虑语言表达（语法）上的准确性； 测评精度会受常用词的干扰； 短译句的测评精度有时会较高； 没有考虑同义词或相似表达的情况，可能会导致合理翻译被否定； BLEU本身就不追求百分之百的准确性，也不可能做到百分之百，它的目标只是给出一个快且不差的自动评估解决方案。 细节后续看，有现成工具可以使用。 MeteorMETEOR标准于2004年由Lavir发现在评价指标中召回率的意义后提出[3] 他们的研究表明，召回率基础上的标准相比于那些单纯基于精度的标准(如BLEU)，其结果和人工判断的结果有较高相关性METEOR测度基于单精度的加权调和平均数和单字召回率，其目的是解决一些BLEU标准中固有的缺陷METEOR也包括其他指标没有发现一些其他功能，如同义词匹配等计算METEOR需要预先给定一组校准(alignment)m，而这一校准基于WordNet的同义词库，通过最小化对应语句中连续有序的块(chunks)ch来得出。 和BLEU不同，METEOR同时考虑了基于整个语料库上的准确率和召回率，而最终得出测度 Dense caption该任务由李飞飞实验室在2017年提出，同时提出了Activity数据集。 该任务类似于图像的dense caption，其中应为视频提供caption及其时间定位。每个caption描述涉及单个主要活动的事件，并且可以在时间轴上彼此重叠。 如上图所示对于一个长时间视频来说，用单caption来概括视频内容可能不是一个好的任务描述方式，不同时间段的不同caption有更好的意义。 参考文献： [1] S. Venugopalan, H. Xu, J. Donahue, M. Rohrbach,R. Mooney, and K. Saenko. Translating videos to natural language using deep recurrent neural networks. In NAACL,2015.1,2,4,5,6,7 [2] S. Venugopalan, M. Rohrbach, J. Donahue, R. Mooney, T. Darrell, and K. Saenko. Sequence to sequence - video to text. In ICCV, December 2015. [3] https://www.jianshu.com/p/e5156a67c71d 双流法 (Two-Stream) 以及 C3D卷积 [4] P. Pan, Z. Xu, Y. Yang, F. Wu, and Y. Zhuang. Hierarchical recurrent neural encoder for video representation with appli- cation to captioning. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 1029–1038, 2016. [5] https://blog.csdn.net/u013010889/article/details/80087601 Video caption tutorial [6] Jiaqi Su. Study of Video Captioning Problem. [7] Krishna R , Hata K , Ren F , et al. Dense-Captioning Events in Videos[J]. 2017. [8] Ji S, Xu W, Yang M, et al. 3D convolutional neural networks for human action recognition[J]. IEEE transactions on pattern analysis and machine intelligence, 2013, 35(1): 221-231. [9] Wang B , Ma L , Zhang W , et al. Reconstruction Network for Video Captioning[J]. 2018.","categories":[{"name":"-paper","slug":"paper","permalink":"http://yoursite.com/categories/paper/"}],"tags":[{"name":"-vedio caption -review","slug":"vedio-caption-review","permalink":"http://yoursite.com/tags/vedio-caption-review/"}]},{"title":"Faster-RCNN","slug":"Faster-RCNN","date":"2019-02-24T07:49:46.000Z","updated":"2019-02-27T08:09:39.509Z","comments":true,"path":"2019/02/24/Faster-RCNN/","link":"","permalink":"http://yoursite.com/2019/02/24/Faster-RCNN/","excerpt":"Faster-RCNN本文假设读者已有图像分类及Fast-RCNN的基础。对于Faster-RCNN来说，数据的流动可以从两个方面来理解，其一是从anchor的产生经过系统的筛选和分类以及回归最后得到候选框及其附加信息的角度出发。二是从输入三维图像矩阵的各种卷积变换到最后得到的结果出发。将两个数据的流动方向结合一起会对理解该模型更有帮助。","text":"Faster-RCNN本文假设读者已有图像分类及Fast-RCNN的基础。对于Faster-RCNN来说，数据的流动可以从两个方面来理解，其一是从anchor的产生经过系统的筛选和分类以及回归最后得到候选框及其附加信息的角度出发。二是从输入三维图像矩阵的各种卷积变换到最后得到的结果出发。将两个数据的流动方向结合一起会对理解该模型更有帮助。 一.RPN anchor机制创造的目的是为了替换掉Fast-RCNN中的selective search算法，在Fast-RCNN算法中，proposal的提取为speed的主要限制，那么提高速度的一个很关键问题是怎么给Proposal提速，那么如何提速呢？ 最自然的一个想法就是使用神经网络，在proposal处理中已经成功的对不同的proposal使用了相同的feature来分类和回归，如果能充分利用features来提取proposal的话，那么提取proposal就基本上没有额外的消耗了。那么如何使用神经网络来提取proposal呢？ 神经网络的基本作用就是分类和回归，也就是对于一个目标可以贴上标签，但是神经网络不可能在得到相同大小的输入的情况下得到不同大小的结果，也就是网络只能对固定数量的输入得到固定数量的输出。 如果我们假设在每个尺寸的图片中都标定一些固定数量和大小的目标框，这些目标框的数量巨大，尺寸丰富，可以涵盖任何一个图像中的bbox，然后用神经网络来对这些框进行前景和背景的分类，并尽量对这些框进行一些修正，就可以把神经网络和proposal提取结合起来，这样我们就得到了Faster-RCNN中最关键的RPN的基本思路。 即在图像上用划窗的形式每隔一个固定的stride（实际上就是feature的stride）生成用不同scale，aspect ratio对基本框进行改变的anchor（文章中3个aspect ratio，3个scale，共9个框）。然后网络对这些anchor进行前景和背景的分类打分，并给出偏移坐标，提取出scores top的候选框再经过NMS就得到了最后的proposal。 上述有几个问题需要说明一下 为什么每隔feature的stride来得到anchor。这里的关键是如何用神经网络来对anchor进行分类和回归，类似的问题还有YOLO中为什么就能得到中心点的物体，再扩展就是为什么卷积神经网络什么都能干。实际上涉及到了如何将神经网络的输出与语义信息结合起来，在图像分类中，一个图片的三维矩阵送入卷积网络输出一个值作为结果，这个值其实是人为赋予的语义信息（如输出3代表飞机类），并给这个图像一个另一个具有语义信息的标签（如5代表汽车类），让这个网络对这个照片输出的值更加接近标签的值就得到了最后的结果，所以实际上训练的过程是让网络输出的值会更加接近人们想让它接近的值。而这个值到底代表了什么要看人们给这个值赋予什么语义信息。简单说就是给网络什么样的标签就会得到什么样的值，再简单说就是，你想要这个值代表什么，并给网络指导信息，这个值就会代表什么。结合问题，输入经过网络后会缩小尺寸stride倍得到feature（H，W，C），我们正好让feature上每一点的通道信息（分类为2*9=18个通道，回归为46个通道）都代表了对原图中以这个点为中心的anchor的分类和偏移，就完成了网络对anchor的分类和回归。 scale 和 aspect ratio是人为设置的超参数，可以根据任务灵活的调整。 如何训练RPN。这里的关键是如何正确的理解目标检测任务的ground-turth。和分类任务中原图的ground-turth直接对结果产生约束不同，训练RPN的标签信息并不是原图的bbox和label，而是通过原图的bbox和label对所有的anchor打标签，所以对于RPN而言真正的ground-truth信息是anchor上的标签。Head Net中的训练方法同理，也需要对proposal打上标签再送入网络中训练。其次，由于每个图片大约有1.6万个anchor，如果全部进行求损失梯度回传的话，正样本会被负样本淹没，这样模型只需要对负样本分类正确就会得到很低的loss。因此回传过程中要人为的挑选一下正负样本的比例和个数，文章中为256个样本，正负比例为1:1。 二.整体框架 上图是论文中Faster-RCNN的整体框架，图像经过基础网络提取特征之后送进RPN中提取proposal，之后将proposal映射到feature上并用ROI Pooling得到每个proposal的固定大小的特征，最后送入分类器和回归器进行回归。 上图为Faster-RCNN代码的整体实现流程。取自https://github.com/chenyuntc/simple-faster-rcnn-pytorch","categories":[{"name":"-paper","slug":"paper","permalink":"http://yoursite.com/categories/paper/"}],"tags":[{"name":"-object-detection -computer-vision","slug":"object-detection-computer-vision","permalink":"http://yoursite.com/tags/object-detection-computer-vision/"}]},{"title":"hexo","slug":"hexo","date":"2019-02-24T07:49:46.000Z","updated":"2019-02-24T08:46:18.116Z","comments":true,"path":"2019/02/24/hexo/","link":"","permalink":"http://yoursite.com/2019/02/24/hexo/","excerpt":"Hexo 使用记录1.安装​ hexo网页就有教程，但还是跟着视频比较合适。 ​ 下载git和node.js，node.js现场下的，git之前就有用过。node -v和git version可以查看版本 2.预处理 终端：hexo init bolog ，生成一个bolog文件夹，并有从github上的文件，算是创建网页 进入 bolog文件夹下，npm install 可以继续下载安装文件夹时失败的文件 hexo g可以generate一系列的网页模版，并在这之后生成public文件夹 hexo s可以运行端口查看网页 ，在http://localhost:4000 3.编写","text":"Hexo 使用记录1.安装​ hexo网页就有教程，但还是跟着视频比较合适。 ​ 下载git和node.js，node.js现场下的，git之前就有用过。node -v和git version可以查看版本 2.预处理 终端：hexo init bolog ，生成一个bolog文件夹，并有从github上的文件，算是创建网页 进入 bolog文件夹下，npm install 可以继续下载安装文件夹时失败的文件 hexo g可以generate一系列的网页模版，并在这之后生成public文件夹 hexo s可以运行端口查看网页 ，在http://localhost:4000 3.编写 题目：hexo new ‘title’可以编写一个文章，并在bolog文件夹下的source里面存放一个markdown文件，该文件只有头字段保留时间等基本信息。可以通过增加内容来写东西。 然后还是hexo g，hexo s来生成网页，这样文章就出现在了网页里面。 hexo new可以生成三种3中文本，hexo new自动生成post，即文章，hexo new draft 生成草稿，hexo new page生成网页页面，模板都在scaffolds里，需要可以修改和增加 4.front meta（文章配置） 是文章的属性信息，由md文件的—在开头括起来，由title，category，comment等属性 yaml语言编写，具体应用现学现用即可 5.配置文件 配置文件为_config.yml 不同区域还有好多个配置文件。 就是对网页，网站的一些配置，可以现学现用，而且太多。 6.hexo命令","categories":[],"tags":[]},{"title":"python","slug":"python","date":"2019-02-24T05:09:32.724Z","updated":"2019-02-24T08:50:49.219Z","comments":true,"path":"2019/02/24/python/","link":"","permalink":"http://yoursite.com/2019/02/24/python/","excerpt":"","text":"本篇文章简单讲解python 的类及format用法，内容在注释。 12345678910111213141516171819202122232425class father(object): def __init__(self,name,age): self.name = name self.age = age def walk(self): print('&#123;&#125; is walking,who is &#123;&#125; years old.'.format(self.name,self.age))#format格式化，其中&#123;&#125;和：是一个作用，实际上&#123;&#125;常用于字符串和直接输出，：常用于数字定义#format 使用。直接在format中写入变量，最好按顺序。#因为在前面&#123;&#125;内可以定义顺序0，1或者填进变量名字，只不过format中要加’=‘，或者直接输入字典。c = father('andy',22) class children(father): def __init__(self,name,age,language): super(children,self).__init__(name,age)#这里再写的时候就没有self了 '''由此可以看到，在子类继承父类属性的时候，在子类初始化的时候一定要包含了父类的全部初始化输入的，否则就不能继承属性 所以要对输入进行增加的时候可以直接继承父类属性，当不需要那么多的时候可以不继承属性。 实际上一般都继承的，因为子类的存在就是改写，对于想改的可以直接写，对于用不到的可以不用，没必要删除。''' self.language = language def eat(self): print('&#123;&#125; is walking,who is &#123;&#125; years old,and this &#123;&#125; is eating'.format(self.name,self.age,self.language))","categories":[{"name":"-code","slug":"code","permalink":"http://yoursite.com/categories/code/"}],"tags":[{"name":"-python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]}